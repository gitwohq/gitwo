name: PAT expiry watchdog

on:
  schedule:
    - cron: '0 9 * * *'   # every day 09:00 UTC
  workflow_dispatch:

jobs:
  check:
    runs-on: ubuntu-22.04
    permissions:
      issues: write
      contents: read
    steps:
      - name: Warn if PAT close to expiry (and avoid duplicates)
        uses: actions/github-script@v7
        env:
          PAT_EXPIRES_AT: ${{ vars.PAT_EXPIRES_AT }}        # YYYY-MM-DD
          PAT_WARN_DAYS: ${{ vars.PAT_WARN_DAYS }}          # optional, default 14
          PAT_SECRET_NAME: ${{ vars.PAT_SECRET_NAME }}      # optional, default HOMEBREW_TAP_GITHUB_TOKEN
          ISSUE_LABELS: ${{ vars.NOTIFY_ISSUE_LABELS }}     # optional, default "security,token-rotation"
          SLACK_WEBHOOK_URL: ${{ secrets.SLACK_WEBHOOK_URL }} # optional
        with:
          script: |
            const { context, core, github } = globals;

            const parseIntSafe = (v, d) => isNaN(parseInt(v,10)) ? d : parseInt(v,10);
            const warnDays   = parseIntSafe(process.env.PAT_WARN_DAYS, 14);
            const secretName = (process.env.PAT_SECRET_NAME || 'HOMEBREW_TAP_GITHUB_TOKEN').trim();
            const labels     = (process.env.ISSUE_LABELS || 'security,token-rotation')
                                 .split(',').map(s => s.trim()).filter(Boolean);

            const expiryRaw = (process.env.PAT_EXPIRES_AT || '').trim();
            if (!expiryRaw) core.setFailed('PAT_EXPIRES_AT is not set');
            const exp = new Date(expiryRaw);
            if (isNaN(exp.getTime())) core.setFailed(`PAT_EXPIRES_AT is invalid date: "${expiryRaw}"`);

            // diff in whole days (ceil so "today at 23:59" counts as 1 day)
            const now  = new Date();
            const msPerDay = 24*60*60*1000;
            const days = Math.ceil((exp - now)/msPerDay);
            core.info(`Days left until ${expiryRaw}: ${days}`);

            // nothing to do if still far away
            if (days > warnDays) {
              core.info(`> More than warn window (${warnDays}d). Exit.`);
              return;
            }

            const owner = context.repo.owner;
            const repo  = context.repo.repo;

            const state = days < 0 ? 'EXPIRED' : 'Rotate';
            const title = `${state} ${secretName} (in ${days} days)`;
            const body  = [
              `Token **${secretName}** expires on **${expiryRaw}**.`,
              '',
              `Days left: **${days}** (warn ≤ ${warnDays}).`,
              '',
              `Action: rotate PAT, update repo secret \`${secretName}\`, refresh \`PAT_EXPIRES_AT\`.`,
            ].join('\n');

            // find open issue with this secretName and our labels to avoid duplicates
            const openIssues = await github.paginate(github.rest.issues.listForRepo, {
              owner, repo, state: 'open', labels: labels.join(','), per_page: 100
            });
            const existing = openIssues.find(i => i.title.includes(secretName));

            if (existing) {
              core.info(`Found existing issue #${existing.number}, updating comment.`);
              await github.rest.issues.createComment({
                owner, repo, issue_number: existing.number,
                body: `Update: **${new Date().toISOString()}** — days left **${days}**.`
              });
            } else {
              core.info('No existing issue found — creating a new one.');
              await github.rest.issues.create({
                owner, repo, title, body, labels
              });
            }

            // optional Slack ping (ignored if no webhook)
            const webhook = process.env.SLACK_WEBHOOK_URL;
            if (webhook) {
              const text = `*${state} ${secretName}* — expires *${expiryRaw}* (days left: ${days}) in \`${owner}/${repo}\``;
              try {
                const res = await fetch(webhook, {
                  method: 'POST',
                  headers: { 'Content-Type': 'application/json' },
                  body: JSON.stringify({ text })
                });
                core.info(`Slack webhook status: ${res.status}`);
              } catch (e) {
                core.warning(`Slack notify failed: ${e.message}`);
              }
            }
